# Written by Felix Hsiao
# Last edit on Jun. 27, 2016 by Felix Hsiao

import time

class prologix_wt310:
    def __init__(self, prologix, addr, mode='RMS', vRange=None, iRange=None,
                 rate=None, debug=False):
        self.prologix = prologix
        self.addr = addr
        self.mode = mode.lower()  # RMS by default
        self.vRange = vRange  # Auto-range by default
        self.iRange = iRange
        self.rate = rate  # Sample period; append "ms" or "MS" for <1 s
                          # Default is 250MS
        self.debug = debug
        self.initialize()


    def initialize(self):
        if self.debug: print 'Initializing address {} in {} mode...'.format(
            self.addr, self.mode)
        self.prologix.set_address(self.addr)
        if self.debug: print 'Reset'
        self.prologix.write('*RST')
        if self.debug: print 'Clear'
        self.prologix.write('*CLS')
        if self.mode is not 'RMS':
            if self.debug: print 'Set mode'
            self.prologix.write('MODE {}'.format(self.mode))
        if self.vRange is not None:
            if self.debug: print 'Set voltage range'
            self.prologix.write('VOLT:RANG {}'.format(self.vRange))
        if self.iRange is not None:
            if self.debug: print 'Set current range'
            self.prologix.write('CURR:RANG {}'.format(self.iRange))
        if self.debug: print 'Set data output to V, I, P'
        self.prologix.write('NUM:NUM 3')
        if self.rate is not None:
            if self.debug: print 'Set sampling period'
            self.prologix.write('RATE {}'.format(self.rate))
        if self.debug: print 'Address {} initialized.'.format(self.addr)


    def getLastSample(self):
        if self.debug: print ('Fetching most recent sample from address ' +
            '{} ...'.format(self.addr))
        self.prologix.set_address(self.addr)
        self.prologix.write('NUM:VAL?')
        time.sleep(0.01)
        data = self.prologix.readline()
        if self.debug: print 'Recv:', data
        return data


    # (Re)start data storage. Data storage automatically stops if memory full;
    # no way to erase data other than restarting storage.
    def restartStorage(self):
        if self.debug: print 'Restarting data storage at address {} ...'.format(
            self.addr)
        self.prologix.set_address(self.addr)
        self.prologix.write('STOR OFF')
        self.prologix.write('STOR ON')
        if self.debug: print 'Address {} data storage restarted.'.format(
             self.addr)


    def stopStorage(self):
        if self.debug: print 'Stopping data storage at address {} ...'.format(
            self.addr)
        self.prologix.set_address(self.addr)
        self.prologix.write('STOR OFF')
        if self.debug: print 'Address {} data storage stopped.'.format(
            self.addr)


    def countData(self):
        if self.debug: print ('Checking number of data blocks stored in ' +
            'address {} ...'.format(self.addr))
        self.prologix.set_address(self.addr)
        self.prologix.write('REC:NUM?')
        time.sleep(0.01)
        blocks = self.prologix.readline()
        if self.debug: print 'Recv:', blocks
        return blocks


    # Cannot find how to retrieve all data at once; automated work-around
    def readData(self):
        if self.debug: print 'Fetching data from address {} ...'.format(
            self.addr)
        self.prologix.set_address(self.addr)
        data = ''
        blockNum = 1
        while blockNum <= int(self.countData()):
            self.prologix.write('REC:VAL? {}'.format(blockNum))
            time.sleep(0.01)
            data += ';' + self.prologix.readline()
            blockNum += 1
        if self.debug: print 'Recv:', data
        return data[1:]


    def checkError(self):
        if self.debug: print ('Checking if error was generated by address ' +
            '{} ...'.format(self.addr))
        self.prologix.set_address(self.addr)
        self.prologix.write('STAT:ERR?')
        time.sleep(0.01)
        data = self.prologix.readline()
        if self.debug: print 'Recv:', data
        return data
